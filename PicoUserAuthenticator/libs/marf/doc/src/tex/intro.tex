\section{Intro}
\noindent
\rule{7.0in}{.013in}

\subsection{What is MARF?}

{\bf MARF} stands for {\bf M}odular {\bf A}udio {\bf R}ecognition {\bf F}ramework.

Four students of Concordia University have started this as a course
project in September 2002. Now it's a project in its own
being maintained and developed as we have time for it. If you have
some suggestions, contributions to make, or for bug reports, don't
hesitate to contact us :-)

Please report bugs to \verb+marf-bugs@lists.sf.net+.

\subsection{Authors}

In alphabetical order:

\begin{itemize}
	\item Ian Cl\'ement, \verb+i_clemen@cs.concordia.ca+
	\item Serguei Mokhov, \verb+mokhov@cs.concordia.ca+, a.k.a Serge
	\item Dimitrios Nicolacopoulos, \verb+d_nicola@cs.concordia.ca+, a.k.a Jimmy
	\item Stephen Sinclair, \verb+step_sin@cs.concordia.ca+, a.k.a. Steve, radarsat1
\end{itemize}

For MARF-related issues please contact us at \verb+marf-devel@lists.sf.net+.

\subsection{Purpose}

Our main goal is to build a general framework to allow developers in the
audio-recognition industry (be it speech, voice, sound, etc.) to choose and apply various methods,
contrast and compare them, and use them in their applications. As a proof of concept, a
user frontend application for Text-Independent (TI) Speaker Identification has
been created on top of the framework (the \verb+SpeakerIdentApp+ program).

\subsection{Project Source and Location}

Our project from the its inception has always been an open-source project.
All releases including the most current one should most of the time be
accessible via \verb+<http://marf.sourceforge.net>+.
We have complete API documentation as well as this manual and all the sources
avilable to download through this web page.

\subsection{Why Java?}

We have chosen to implement our project using the Java programming language. This
choice is justified by the binary portability of the Java applications as well as
facilitating memory management tasks and other issues, so we can concentrate more on
the algorithms instead. Java also provides
us with built-in types and data-structures to manage
collections (build, sort, store/retrieve) efficiently.
